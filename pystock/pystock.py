import datetime as dt
import pandas as pd
import numpy as np
import math
from scipy.optimize import fsolve
import yfinance as yahooFinance
from pandas_datareader import data as pdr


def fetch_stock_data(ticker: str, length: int) -> pd.DataFrame:
    """fetches pandas dataframe of stock prices for a given ticker

    Args:
        ticker (str): stock ticker
        length (int): number of days of data to fetch

    Raises:
        TypeError: incorrect/inavlid type given to function
        ConnectionError: invalid ticker given to function

    Returns:
        pd.DataFrame: dataframe containing stock data
    """
    if not isinstance(ticker, str) or not isinstance(length, int) or length < 2:
        raise TypeError()

    end = dt.datetime.now()
    start = end - dt.timedelta(days=length)

    yahooFinance.pdr_override()

    df = pdr.get_data_yahoo(ticker, start, end)

    if df.empty:
        raise ConnectionError("Invalid Ticker")

    return df


def calculate_black_scholes_sigma(dataframe: pd.DataFrame) -> float:
    """calculate the sigma value for the black-scholes equation

    Args:
        dataframe (pd.DataFrame): stock dataframe generated by fetch_stock_data

    Returns:
        float: sigma value calculated from black-scholes equation
    """
    if dataframe is not pd.DataFrame:
        raise TypeError

    dataframe["Mean"] = (dataframe["High"] + dataframe["Low"]) / 2
    mean = dataframe["Mean"].mean()
    variance = dataframe["Mean"].var()

    def generate_black_scholes_system_of_equations(vars):
        return [
            math.exp(2 * math.log(mean))
            + vars[0] ** 2 * math.exp(vars[0])
            - math.exp(2 * math.log(mean) - vars[0] ** 2)
            - vars[0] ** 2
            - variance,
        ]

    sigma = fsolve(generate_black_scholes_system_of_equations, [0.1])

    return sigma


def black_scholes_predict_next(
    price: float, interest: float, sigma: float, timedelta: float, epsilon: float = 0
):
    """predicts the next stock price based on the black-scholes algorithm

    Args:
        price (float): current price of stock
        interest (float): interest rate of stock
        sigma (float): black-scholes sigma value
        timedelta (float): amount of time passed for this prediction
        epsilon (float, optional): value for testing. Defaults to 0.

    Raises:
        TypeError: incorrect input type input

    Returns:
        float: predicted stock price after timedelta
    """
    if (
        not isinstance(price, float)
        or not isinstance(interest, float)
        or not isinstance(sigma, float)
        or not isinstance(timedelta, float)
    ):
        raise TypeError

    if epsilon == 0:
        epsilon = np.random.normal()
    return price * np.exp(
        (interest - (sigma**2) / 2) * timedelta + sigma * np.sqrt(timedelta) * epsilon
    )


def simulate_stock_price(price: float, interest: float, sigma: float, num_days: int):
    """simulate stock prices for a certain number of days

    Args:
        price (float): current stock price
        interest (float): stock interest rate
        sigma (float): black-scholes sigma value
        num_days (int): number of days to simulate

    Raises:
        TypeError: _description_

    Returns:
        np.array: array of predicted stock prices
    """
    if (
        not isinstance(price, float)
        or not isinstance(interest, float)
        or not isinstance(sigma, float)
        or not isinstance(num_days, int)
    ):
        raise TypeError

    timedelta = 1 / num_days
    predicted_prices = [price]

    predicted_prices.extend(
        predicted_prices.append(
            black_scholes_predict_next(
                predicted_prices[idx], interest, sigma, timedelta
            )
        )
        for idx in range(num_days - 1)
    )

    return np.array(predicted_prices)
